import 'package:hive_flutter/hive_flutter.dart';
import '../models/conversation_model.dart';
import '../models/message_model.dart';
import '../models/user_model.dart';

class StorageService {
  static const String conversationsBox = 'conversations';
  static const String messagesBox = 'messages';

  Future<void> initialize() async {
    await Hive.initFlutter();
    
    // Register adapters (generated by build_runner)
    Hive.registerAdapter(UserModelAdapter());
    Hive.registerAdapter(ConversationModelAdapter());
    Hive.registerAdapter(MessageModelAdapter());
    
    try {
      await Hive.openBox<ConversationModel>(conversationsBox);
      await Hive.openBox<MessageModel>(messagesBox);
    } catch (e) {
      // If opening boxes fails (schema mismatch), delete and recreate them
      print('Error opening Hive boxes, clearing corrupted data: $e');
      await Hive.deleteBoxFromDisk(conversationsBox);
      await Hive.deleteBoxFromDisk(messagesBox);
      await Hive.openBox<ConversationModel>(conversationsBox);
      await Hive.openBox<MessageModel>(messagesBox);
    }
  }

  // Conversations
  Future<void> saveConversation(ConversationModel conversation) async {
    final box = Hive.box<ConversationModel>(conversationsBox);
    await box.put(conversation.id, conversation);
  }

  Future<void> saveConversations(List<ConversationModel> conversations) async {
    final box = Hive.box<ConversationModel>(conversationsBox);
    for (var conversation in conversations) {
      await box.put(conversation.id, conversation);
    }
  }

  List<ConversationModel> getConversations() {
    final box = Hive.box<ConversationModel>(conversationsBox);
    final conversations = box.values.toList();
    conversations.sort((a, b) => b.lastMessageAt.compareTo(a.lastMessageAt));
    return conversations;
  }

  Future<void> deleteConversation(String conversationId) async {
    final box = Hive.box<ConversationModel>(conversationsBox);
    await box.delete(conversationId);
    
    // Delete associated messages
    await deleteMessagesByConversation(conversationId);
  }

  Future<void> clearConversations() async {
    final box = Hive.box<ConversationModel>(conversationsBox);
    await box.clear();
  }

  // Messages
  Future<void> saveMessage(MessageModel message) async {
    if (message.isExpired) return; // Don't save expired messages
    
    final box = Hive.box<MessageModel>(messagesBox);
    await box.put(message.id, message);
  }

  Future<void> saveMessages(List<MessageModel> messages) async {
    final box = Hive.box<MessageModel>(messagesBox);
    for (var message in messages) {
      if (!message.isExpired) {
        await box.put(message.id, message);
      }
    }
  }

  List<MessageModel> getMessages(String conversationId) {
    final box = Hive.box<MessageModel>(messagesBox);
    final allMessages = box.values.toList();
    
    // Filter by conversation and remove expired messages
    final messages = allMessages
        .where((m) => m.conversationId == conversationId && !m.isExpired)
        .toList();
    
    messages.sort((a, b) => a.createdAt.compareTo(b.createdAt));
    return messages;
  }

  Future<void> deleteMessage(String messageId) async {
    final box = Hive.box<MessageModel>(messagesBox);
    await box.delete(messageId);
  }

  Future<void> deleteMessagesByConversation(String conversationId) async {
    final box = Hive.box<MessageModel>(messagesBox);
    final messagesToDelete = box.values
        .where((m) => m.conversationId == conversationId)
        .toList();
    
    for (var message in messagesToDelete) {
      await box.delete(message.id);
    }
  }

  Future<void> cleanupExpiredMessages() async {
    final box = Hive.box<MessageModel>(messagesBox);
    final expiredMessages = box.values.where((m) => m.isExpired).toList();
    
    for (var message in expiredMessages) {
      await box.delete(message.id);
    }
  }

  Future<void> clearAllData() async {
    await clearConversations();
    final box = Hive.box<MessageModel>(messagesBox);
    await box.clear();
  }
}
